package vcssyncer

import (
	"context"
	"io"
	"net/url"
	"os"
	"path/filepath"

	"github.com/sourcegraph/log"

	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/common"
	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/git"
	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/gitserverfs"
	"github.com/sourcegraph/sourcegraph/internal/api"
	"github.com/sourcegraph/sourcegraph/internal/vcs"
	"github.com/sourcegraph/sourcegraph/internal/wrexec"
	"github.com/sourcegraph/sourcegraph/lib/errors"
)

// generatingSyncer is a syncer that generates a git repository from a generator
// command.
// The git repository is generated by running the generator command in a temporary
// directory and then using the git VCS syncer implementation to do a fetch from
// this temporary directory, so that the syncer ultimately also runs through the
// Git layer.
type generatingSyncer struct {
	logger                  log.Logger
	recordingCommandFactory *wrexec.RecordingCommandFactory
	fs                      gitserverfs.FS
	update                  func(ctx context.Context, repoName api.RepoName, dir common.GitDir, progressWriter io.Writer) error
	isCloneable             func(ctx context.Context, repoName api.RepoName) error
	typ                     string
}

func NewGeneratingSyncer(
	logger log.Logger,
	r *wrexec.RecordingCommandFactory,
	fs gitserverfs.FS,
	update func(ctx context.Context, repoName api.RepoName, dir common.GitDir, progressWriter io.Writer) error,
	isCloneable func(ctx context.Context, repoName api.RepoName) error,
	typ string,
) VCSSyncer {
	return &generatingSyncer{
		logger:                  logger.Scoped("GeneratingSyncer"),
		recordingCommandFactory: r,
		fs:                      fs,
		update:                  update,
		isCloneable:             isCloneable,
		typ:                     typ,
	}
}

func (s *generatingSyncer) Type() string {
	return s.typ
}

func (s *generatingSyncer) IsCloneable(ctx context.Context, repoName api.RepoName) error {
	return s.isCloneable(ctx, repoName)
}

func (s *generatingSyncer) Fetch(ctx context.Context, repoName api.RepoName, dir common.GitDir, progressWriter io.Writer) error {
	// Make a temporary dir to store the generated repo.
	tmpRepoDir, err := s.fs.TempDir("generate-repo-")
	if err != nil {
		return errors.Wrap(err, "create temp dir")
	}
	defer func() {
		// Best effort clean up the generated repo dir after the fetch is complete.
		// If this fails, it will eventually be cleaned up by the gitserverfs.FS
		// cleanup routine that purges data from the tmp dir.
		rmErr := os.RemoveAll(tmpRepoDir)
		if rmErr != nil {
			s.logger.Error("failed to clean up temp dir", log.Error(err), log.String("repo", string(repoName)))
		}
	}()

	if err := git.MakeBareRepo(ctx, tmpRepoDir); err != nil {
		return errors.Wrap(err, "make bare repo")
	}

	repoObjectsDir := dir.Path("objects")
	if err := os.WriteFile(filepath.Join(tmpRepoDir, "objects/info/alternates"), []byte(repoObjectsDir+"\n"), os.ModePerm); err != nil {
		return errors.Wrap(err, "write alternates file")
	}

	if err := s.update(ctx, repoName, common.GitDir(tmpRepoDir), progressWriter); err != nil {
		return errors.Wrap(err, "failed to run generate repo step")
	}

	gitSyncer := &gitRepoSyncer{
		logger:                  s.logger,
		recordingCommandFactory: s.recordingCommandFactory,
		getRemoteURLSource: func(ctx context.Context, name api.RepoName) (RemoteURLSource, error) {
			return RemoteURLSourceFunc(func(ctx context.Context) (*vcs.URL, error) {
				// Fetch the new objects from the repo on disk, but go through the Git repository syncer
				// implementation, so that we get the same Git layer implementation.
				// Historically, we used to let the syncer implementation itself manage the repo
				// on disk, but that led to inconsistencies like HEAD not getting touched after an
				// update which incorrectly marked the repo as not fetched in a while.
				return &vcs.URL{
					URL: url.URL{
						Scheme: "file",
						Path:   tmpRepoDir,
					},
				}, nil
			}), nil
		},
	}

	return gitSyncer.Fetch(ctx, repoName, dir, progressWriter)
}
